// Copyright (c) 2014 AEFIS, all rights reserved.
// http://www.aefis.com/
"use strict";

if (!aefis) {
	aefis = {};
}

aefis.CurrentPage = function () {
	var that = this;

	this.initialize = function ($rootContainer) {
		if ($rootContainer.is("body")) {
			if ($().chart) {
				$rootContainer.find(".bulletChart").each(function () {
					$(this).chart({ chartOptions: metricChart });
				});
				$rootContainer.find(".columnChart").each(function () {
					var $parent = $(this).parent().parent();
					var target = $parent.attr("data-aefis-target");
					if (target) {
						var $target = $(target);
						var targetHeight = $target.height() - 55;
						$(this).height(targetHeight);
						$(this).parent().height(targetHeight);
						$(this).attr("data-aefis-height", targetHeight + "px");
						$parent.height($target.height());
					}
					// $container.height
					$(this).chart({ chartOptions: columnChart });
				});
			}

			$("div.heliocampus-comment-container").each(function () {
				var $container = $(this);
				var target = $container.attr("data-aefis-target");
				var $target = $(target);
				var params = $container.attr("data-aefis-params");
				var comments = $target.html();
				var enableai = $container.attr("data-aefis-enableai");
				var title = "All Text Responses";
				setTimeout(function () {
					ui.ReactDOM.render(
						ui.React.createElement(ui.SurveyCommentsSummary, {
							params: JSON.parse(params),
							title: title,
							comments: JSON.parse(comments),
							enableAI: enableai == "true" ? true : false,
							onRef: function (innerChild) {
								window.surveyCommentsSummary = innerChild;
							}
						}),
						$container.get(0)
					);
				}, 0);
			});
		}

		setTimeout(function () {
			$(document).trigger("pagecomplete");
		}, 5000);
	};

	(function (H) {
		var rel = H.relativeLength;

		H.wrap(H.seriesTypes.column.prototype, "translate", function (proceed) {
			var options = this.options,
				topMargin = options.topMargin || 0,
				bottomMargin = options.bottomMargin || 0;

			proceed.call(this);

			H.each(this.points, function (point) {
				var shapeArgs = point.shapeArgs,
					w = shapeArgs.width,
					h = shapeArgs.height,
					x = shapeArgs.x,
					y = shapeArgs.y;

				// Get the radius
				var rTopLeft = rel(options.borderRadiusTopLeft || 0, w),
					rTopRight = rel(options.borderRadiusTopRight || 0, w),
					rBottomRight = rel(options.borderRadiusBottomRight || 0, w),
					rBottomLeft = rel(options.borderRadiusBottomLeft || 0, w);

				if (rTopLeft || rTopRight || rBottomRight || rBottomLeft) {
					var maxR = Math.min(w, h) / 2;

					if (rTopLeft > maxR) {
						rTopLeft = maxR;
					}

					if (rTopRight > maxR) {
						rTopRight = maxR;
					}

					if (rBottomRight > maxR) {
						rBottomRight = maxR;
					}

					if (rBottomLeft > maxR) {
						rBottomLeft = maxR;
					}

					// Preserve the box for data labels
					point.dlBox = point.shapeArgs;

					point.shapeType = "path";
					point.shapeArgs = {
						d: [
							"M",
							x + rTopLeft,
							y + topMargin,
							// top side
							"L",
							x + w - rTopRight,
							y + topMargin,
							// top right corner
							"C",
							x + w - rTopRight / 2,
							y,
							x + w,
							y + rTopRight / 2,
							x + w,
							y + rTopRight,
							// right side
							"L",
							x + w,
							y + h - rBottomRight,
							// bottom right corner
							"C",
							x + w,
							y + h - rBottomRight / 2,
							x + w - rBottomRight / 2,
							y + h,
							x + w - rBottomRight,
							y + h + bottomMargin,
							// bottom side
							"L",
							x + rBottomLeft,
							y + h + bottomMargin,
							// bottom left corner
							"C",
							x + rBottomLeft / 2,
							y + h,
							x,
							y + h - rBottomLeft / 2,
							x,
							y + h - rBottomLeft,
							// left side
							"L",
							x,
							y + rTopLeft,
							// top left corner
							"C",
							x,
							y + rTopLeft / 2,
							x + rTopLeft / 2,
							y,
							x + rTopLeft,
							y,
							"Z"
						]
					};
				}
			});
		});
	})(Highcharts);

	function metricChart(data, chartForm) {
		var average = data.Average;
		var expectedSuccess = data.ExpectedSuccess;
		var isSuccessful = data.IsSuccessful;
		var lowerRange = data.LowerRange;
		var upperRange = data.UpperRange;
		var successColor = "#C8E6C9";
		var notSuccessColor = "#eeeeee";
		var seriesColor = "rgb(33, 150, 243)";
		var pointFormatText = "Metric Average: <b>{point.y}</b>";

		var minValue = lowerRange;
		var maxValue = upperRange;

		if (!expectedSuccess || (expectedSuccess && expectedSuccess == "")) {
			expectedSuccess = 0;
		}
		//average = average.toFixed(2);

		if (expectedSuccess > 0) {
			var maxUpperRange = upperRange;
			upperRange = expectedSuccess;
			pointFormatText =
				"Metric Average: <b>{point.y}</b><br/>(with success target at {point.target})";
			//notSuccessColor = '#FFCCBC';
		}

		var plotbandArray = [
			{
				from: lowerRange,
				to: upperRange,
				color: notSuccessColor
			}
		];

		if (expectedSuccess > 0) {
			plotbandArray.push({
				from: upperRange,
				to: maxUpperRange,
				color: successColor
			});
		}

		var targetOptionsObject = {
			width: "0%",
			height: 0,
			borderWidth: 0,
			borderColor: "#4CAF50",
			color: "#4CAF50"
		};

		var seriesObject = {
			data: [
				{
					y: average,
					target: expectedSuccess
				}
			],
			targetOptions: targetOptionsObject
		};

		var options = {
			chart: {
				inverted: true,
				marginLeft: 0,
				type: "bullet"
			},
			title: null,
			credits: {
				enabled: false
			},
			legend: {
				enabled: false
			},
			yAxis: {
				floor: minValue,
				ceiling: maxValue,
				max: maxValue,
				gridLineWidth: 0,
				plotBands: plotbandArray,
				title: null
			},
			xAxis: {
				categories: [""]
			},
			plotOptions: {
				series: {
					pointPadding: 0,
					borderWidth: 0,
					color: seriesColor,
					targetOptions: {
						width: "200%"
					}
				}
			},
			series: [seriesObject],
			tooltip: {
				pointFormat: pointFormatText
			}
		};

		return options;
	}

	function columnChart(data, chartForm) {
		if (!data || data.length == 0) {
			return;
		}

		var options = {
			chart: {
				type: "column",
				colorScheme: 1
			},
			title: null,
			credits: {
				enabled: false
			},
			legend: {
				enabled: false
			},
			tooltip: {
				followPointer: true,
				valueDecimals: 0,
				formatter: function () {
					var text = "Option Value: " + this.key + "<br />Count:" + this.y;

					return text;
				}
			},
			xAxis: {
				type: "category",
				gridLineColor: null,
				gridLineWidth: 0
			},
			yAxis: {
				min: 0,
				// tickInterval:1,
				alternateGridColor: null,
				allowDecimals: false,
				title: null
			},
			plotOptions: {
				series: {
					borderWidth: 0,
					borderRadiusTopRight: 6,
					borderRadiusTopLeft: 6,
					color: "#2196F3",
					dataLabels: {
						enabled: true,
						color: "#333",
						align: "center",
						formatter: function () {
							if (this.y != 0) {
								return this.y;
							} else {
								return null;
							}
						}
					}
				}
			},
			series: [
				{
					data: data
				}
			]
		};
		return options;
	}
};

/*// Copyright (c) 2014 AEFIS, all rights reserved.
// http://www.aefis.com/
"use strict";

if (!aefis) {
	aefis = {};
};

aefis.CurrentPage = function () {
	var that = this;
	
	this.initialize = function ($rootContainer) {

		if ($rootContainer.is('body')) {
			if ($().chart) {
				$rootContainer.find(".columnChart").each(function(){
					$(this).chart({ chartOptions:columnChart });

				});
			}
		}

		setTimeout(function() {
			$(document).trigger('pagecomplete'); 
		}, 5000);

	};

	function columnChart (data, chartForm) {
		if (!data || data.length == 0) {
			return;
		};

		var options = {
			chart: {
            	type: 'pie'
        	},
       		title: null,
	        credits: {
            	enabled: false
        	},
            legend: {
    align: 'left',
    enabled: true,
    layout: 'vertical',
    verticalAlign: 'top',
    x: 40,
    y: 0
},
			tooltip: {
                formatter: function() {
                    return '<b>'+ this.point.name +'</b>: '+ this.y +' response(s)';
                }
            },
	        plotOptions: {
                pie: {
                    shadow: false
                  
                }
            },
	       series: [{
                name: 'Responses',
                 colorByPoint: true,
                   colors: ['#ED561B','#FF9655','#DDDF00','#FFF263', '#058DC7', '#50B432' ,  '#24CBE5', '#64E572', '#6AF9C4'],
                data: data,
                size: '130%',
                innerSize: '70%',
                showInLegend:true,
                dataLabels: {
                    enabled: false
                }
            }]
	      };
		return options;
	};
	
};
*/
